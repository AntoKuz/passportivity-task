# AI Log - Использование AI инструментов в разработке

## Обзор

В процессе разработки этого проекта активно использовались AI-инструменты для ускорения разработки и улучшения качества кода. Основные инструменты: **Cursor AI** и **Context7**. В качестве доп. инстуремнта для поиска информации испльзовался perplexity

## Используемые AI инструменты

### 1. Cursor AI
Основной инструмент разработки - IDE на базе VSCode с встроенным AI-ассистентом.

**Основные сценарии использования:**
- Автодополнение кода
- Генерация компонентов и функций
- Рефакторинг существующего кода
- Объяснение сложных паттернов
- Отладка ошибок

### 2. Context7
Использовался для получения актуальной документации по библиотекам и фреймворкам.

**Основные сценарии использования:**
- Изучение API Next.js 16 и React 19
- Работа с Octokit.js
- Лучшие практики Tailwind CSS
- TypeScript типизация

## Конкретные примеры использования

### Пример 0: Планирование проекта с использованием AI

**Начальный этап:**
Первым шагом я воспользовался **режимом планировщика** (Plan Mode) в Cursor, для формирования структурированного плана работы.

**Промпт:**
```
Вот тестовое задание для создания Git Commit History Viewer.
Проанализируй требования и создай пошаговый план разработки.
```

**Результат от AI:**
Cursor AI сгенерировал детальный план, который включал:
- Настройку Next.js 16 проекта с App Router
- Интеграцию с GitHub API через Octokit
- Реализацию Server Components и Server Actions
- UI компоненты с Tailwind CSS
- Дополнительные фичи (dark mode, анимации, скелетоны)

**Моя корректировка плана:**
Внимательно изучив предложенный план, я принял стратегическое решение переприоритизировать задачи:

1. **Фокус на core функционале** (MVP):
   - ✅ Получение и отображение коммитов
   - ✅ Server Actions с правильной обработкой состояния
   - ✅ Auto-updating timestamps
   - ✅ Refresh функционал

2. **Дополнительные фичи** (отложены на второй этап):
   - Dark mode
   - Анимации и transitions
   - UI полировка
  
3  **Написание документации**
    -AI_LOG.md
    -ARCHITECTURE.md
    -README.md

**Итеративная работа:**
После утверждения плана начал работать пошагово, используя Cursor AI как напарника:
- Каждый этап плана превращал в конкретные промпты. Использовал каждый раз новое контекстное окно.
- Проверял результат, тестировал, корректировал
- Постепенно добавлял дополнительные фичи

Такой подход позволил:
- Не потеряться в деталях на начальном этапе
- Иметь рабочую версию уже через 1-2 часа
- Итеративно улучшать продукт

### Пример 1: Core функционал - MVP (Этап 1)

#### 1.1 Создание структуры проекта и GitHub API интеграция

**Промпт:**
```
Создай структуру Next.js App Router проекта для отображения коммитов из GitHub.
Используй TypeScript, Tailwind, и Octokit. Нужны компоненты для списка коммитов,
отдельного коммита, и кнопки обновления с использованием Server Actions.
```

**Результат:**
- ✅ Cursor создал базовую структуру папок `/app`, `/components`, `/lib`
- ✅ Предложил правильное разделение на server и client компоненты
- ✅ Сгенерировал типы в `lib/types.ts`
- ✅ Настроил интеграцию с GitHub API через Octokit

**Что пришлось доработать:**
- Добавил более детальную типизацию для GitHub API response
- Добавил обработку ошибок для rate limiting (403/404)
- Переработал структуру компонентов для лучшей переиспользуемости

#### 1.2 Реализация автообновления времени

**Промпт:**
```
Создай React компонент RelativeTime, который показывает относительное время
(например "2 minutes ago") и автоматически обновляется каждую минуту без
перезагрузки страницы. Используй date-fns.
```

**Результат:**
- ✅ Cursor сгенерировал компонент с `useEffect` и `setInterval`
- ✅ Правильно использовал `formatDistanceToNow` из date-fns
- ✅ Корректно очистил интервал при unmount

**Что работало отлично:**
- Код работал сразу без доработок
- Правильная обработка memory leaks через cleanup function

#### 1.3 Server Actions с useFormStatus

**Промпт:**
```
Реализуй кнопку обновления коммитов используя Server Actions и useFormStatus
из React. Нужно показывать loading состояние без мерцания, использовать
скелетоны во время загрузки.
```

**Результат:**
- ⚠️ Первая версия имела проблемы с типизацией FormData
- ⚠️ Loading состояние работало, но был заметный flicker

**Что пришлось переделать:**
- Разделил на два компонента: `RefreshCommitsForm` и `RefreshButton`
- Добавил локальное состояние `isRefreshing` в `CommitsSection`
- Улучшил UX с помощью скелетонов и плавных анимаций

**Финальное решение:**
```typescript
// Cursor предложил базовую структуру, но я оптимизировал её
async function handleRefresh() {
  const newCommits = await refreshCommitsData(defaultBranch);
  setCommits(newCommits);
}
```

#### 1.4 Получение документации через Context7

**Запрос в Context7:**
```
Next.js Server Actions best practices
```

**Полученная информация:**
- Как правильно использовать `'use server'` directive
- Паттерны обработки ошибок в Server Actions
- Интеграция с `revalidatePath` для обновления кэша

**Применение:**
Использовал рекомендации при создании `app/actions.ts`:
```typescript
export async function refreshCommitsData(branch: string): Promise<Commit[]> {
  try {
    return await getCommits(branch);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    throw new Error(`Failed to refresh commits: ${errorMessage}`);
  }
}
```

### Пример 2: Дополнительные фичи (Этап 2)

#### 2.1 Dark Mode реализация

**Промпт:**
```
Добавь dark mode toggle с использованием Tailwind CSS и localStorage.
Нужен плавный переход между темами и иконки солнца/луны.
```

**Результат:**
- ✅ Cursor создал полностью рабочий компонент `ThemeToggle`
- ✅ Правильно использовал `useEffect` для инициализации темы
- ✅ Добавил анимации переходов

**Что улучшил:**
- Добавил более плавные анимации для иконок
- Улучшил accessibility (ARIA labels)
- Оптимизировал цветовую схему для лучшей читаемости

#### 2.2 UI полировка и анимации

**Промпт:**
```
Улучши UI компонента CommitItem, добавь плавные анимации при появлении,
hover эффекты и улучшенную типографику.
```

**Результат:**
- ✅ Добавил skeleton loaders для плавной загрузки
- ✅ Реализовал анимацию появления элементов (fade-in)
- ✅ Создал адаптивную верстку для мобильных устройств

**Что улучшил:**
- Цветовая палитра и градиенты
- Card-based дизайн с тенями и border-radius
- Responsive grid layout для списка коммитов

### Пример 3: Документация (Этап 3)

#### 3.1 Написание AI_LOG.md

**Задача:**
Создать подробный отчет об использовании AI-инструментов в проекте.

**Подход:**
Использовал Cursor AI для структурирования документа:
- Попросил создать шаблон AI_LOG.md на основе тестового задания
- AI сгенерировал структуру с нужными секциями
- Я дополнил реальными примерами из своего опыта

**Результат:**
- ✅ Полная документация всех AI-интерракций
- ✅ Конкретные примеры промптов и результатов
- ✅ Анализ сильных и слабых сторон AI
- ✅ Рефлексия о влиянии на workflow

#### 3.2 Написание ARCHITECTURE.md

**Задача:**
Спроектировать масштабируемую архитектуру для 1000+ репозиториев.

**Подход:**
1. Проанализировал текущую реализацию проекта
2. Использовал Perplexity для поиска best practices по масштабированию
3. Context7 для получения документации по Redis, Next.js cache strategies
4. Cursor AI для структурирования и написания кодовых примеров

**Результат:**
- ✅ Детальная frontend архитектура с виртуализацией
- ✅ Многоуровневая стратегия кэширования
- ✅ Разделение server/client логики
- ✅ Monitoring и observability решение
- ✅ Инфраструктура и CI/CD

**Challenges:**
- AI предложил слишком сложные решения для текущего масштаба
- Пришлось самостоятельно продумать баланс между simplicity и scalability

## Где AI помог больше всего

### ✅ Сильные стороны:

1. **Быстрая генерация boilerplate кода**
   - Структура проекта создана за минуты вместо часов
   - Стандартные паттерны (useState, useEffect) генерируются мгновенно

2. **Работа с TypeScript**
   - Cursor отлично справляется с выводом типов
   - Предлагает правильные generic типы для React компонентов

3. **Tailwind CSS классы**
   - Автодополнение Tailwind классов работает идеально
   - Предложения адаптивных классов (sm:, md:, lg:)

4. **Рефакторинг**
   - Быстрое извлечение компонентов
   - Переименование переменных с учетом всех зависимостей

5. **Документация в реальном времени**
   - Context7 предоставлял актуальную документацию Next.js 16 и React 19
   - Помог избежать устаревших паттернов

## Где AI не справился / требовалась доработка

### ⚠️ Слабые стороны:

1. **Архитектурные решения**
   - AI предлагал стандартные решения, но не всегда оптимальные
   - Пришлось самостоятельно продумывать разделение на server/client компоненты

2. **Обработка edge cases**
   - Rate limiting GitHub API: AI не предложил fallback стратегию
   - Добавил обработку 403/404 ошибок вручную

3. **UX детали**
   - AI создавал функциональные компоненты, но без полировки
   - Анимации, transitions, loading states требовали ручной доработки

4. **Оптимизация производительности**
   - AI не предложил мемоизацию для предотвращения ре-рендеров
   - Пришлось самостоятельно оптимизировать `RelativeTime` компонент

## Отклоненные предложения AI

### Пример 1: Избыточная абстракция
**Что предложил AI:**
Создать отдельный Context для управления темой с Provider на уровне layout.

**Почему отклонил:**
Для такого маленького проекта это избыточно. Использовал простой компонент с localStorage.

### Пример 2: Клиентский GitHub API запрос
**Что предложил AI:**
Делать запросы к GitHub API напрямую из клиентского компонента.

**Почему отклонил:**
Это небезопасно - токен был бы виден в браузере. Переместил всю логику в Server Actions и API routes.

### Пример 3: Использование SWR для кэширования
**Что предложил AI:**
Использовать библиотеку SWR для автоматического кэширования и ре-валидации.

**Почему отклонил:**
Хотел показать понимание нативных Next.js паттернов (Server Components, Server Actions). SWR добавил бы зависимость без явной необходимости.

## Рефлексия: влияние AI на workflow

### Положительное влияние:

1. **Скорость разработки увеличилась в 2-3 раза**
   - Рутинные задачи (типизация, boilerplate) выполняются мгновенно
   - Больше времени на архитектуру и UX

2. **Снижение когнитивной нагрузки**
   - Не нужно помнить точный синтаксис каждой библиотеки
   - AI подсказывает правильные API методы

3. **Изучение новых технологий**
   - Быстрее разобрался с новыми фичами Next.js 16 и React 19
   - Context7 предоставлял актуальные примеры кода

4. **Качество кода**
   - AI следит за консистентностью стиля
   - Предлагает более читаемые варианты кода

### Вызовы и ограничения:

1. **Критическое мышление остается важным**
   - Нельзя слепо доверять AI предложениям
   - Необходимо понимать, что делает сгенерированный код

2. **AI не заменяет опыт**
   - Архитектурные решения требуют человеческого понимания контекста
   - AI не всегда учитывает требования масштабируемости

3. **Иногда проще написать самому**
   - Для простых задач объяснение AI занимает больше времени
   - Короткие функции быстрее написать вручную

## Выводы

AI-инструменты (Cursor + Context7) стали неотъемлемой частью моего workflow:

- **Для рутинных задач**: AI справляется на 90-95%
- **Для сложной логики**: AI помогает на 50-60%, остальное требует доработки
- **Для архитектуры**: AI предлагает базу, но финальные решения принимаю сам

**Главный принцип работы с AI:**
> AI - это инструмент для усиления продуктивности, а не замена инженерного мышления.

Я использовал AI как **умного напарника**, который:
- Помогает с синтаксисом и API
- Предлагает варианты решений
- Ускоряет написание boilerplate кода
- Пишет документацию

Но финальные решения по архитектуре, UX, и оптимизациям принимал самостоятельно, основываясь на понимании требований проекта.

